#include "../include/phalange.h"
#include <geometry_msgs/PoseStamped.h>
#include <tf_conversions/tf_eigen.h>
#include <Eigen/Core>

Phalange::Phalange(tf::Transform const & L_T_Cref,Model const & model, std::string const & sensor_topic) : nh_private_("~"),L_T_Cref_(L_T_Cref),C_T_O_(new icr::StampedContactPose),
													   phalange_model_(new Model(model)), object_model_(new Model(model))
{
  std::string searched_param;
  nh_private_.searchParam("tf_prefix",searched_param);
  nh_private_.getParam(searched_param, tf_prefix_);

  L_T_Cref_.setRotation(L_T_Cref_.getRotation().normalize());//ensure normalized orientation

  contacts_subs_=nh_.subscribe<gazebo_msgs::ContactsState>(sensor_topic, 1, &Phalange::listenContacts, this);
  ct_pose_pub_=nh_.advertise<geometry_msgs::PoseStamped>(phalange_model_->name_ + "/contact_pose",1);
  set_pose_srv_ = nh_.advertiseService(phalange_model_->name_ + "/set_ref_contact_pose",&Phalange::setPose,this);

  //Initialize the filter
  tf_filter_ = new tf::MessageFilter<icr::StampedContactPose>(tf_list_, object_model_->frame_id_, 10);
  tf_filter_->registerCallback(boost::bind(&Phalange::transformContactPose, this, _1) );
}
//---------------------------------------------------------------------
Phalange::~Phalange(){delete tf_filter_;}
//---------------------------------------------------------------------
void Phalange::transformContactPose(const boost::shared_ptr<const icr::StampedContactPose>& C_T_L)
{
  geometry_msgs::PoseStamped P_in, P_out;
  P_in.header=C_T_L->header;
  P_in.pose=C_T_L->contact_pose.pose;

  //Compute the current contact pose w.r.t. the object frame 
  tf_list_.transformPose(object_model_->frame_id_,P_in,P_out); 

  lock_.lock();
  
  C_T_O_->header.stamp=C_T_L->header.stamp;
  C_T_O_->header.frame_id=object_model_->frame_id_;
  C_T_O_->contact_pose.pose=P_out.pose;
  C_T_O_->contact_pose.touching=C_T_L->contact_pose.touching;
  lock_.unlock();
}
//---------------------------------------------------------------------
void Phalange::listenContacts(const gazebo_msgs::ContactsState::ConstPtr& cts_st)
{
  icr::StampedContactPose::Ptr C_T_L(new icr::StampedContactPose);
  C_T_L->header.stamp=cts_st->header.stamp;
  C_T_L->header.frame_id=tf_prefix_ + phalange_model_->frame_id_;

  lock_.lock();   
  //Check whether the phalange geometry is in contact with the target object geometry
  for(unsigned int i=0; i < cts_st->states.size();i++)
    if((cts_st->states[i].geom1_name == phalange_model_->geom_) && (cts_st->states[i].geom2_name == object_model_->geom_))     
      {
	//Contact position is generated by averaging over all points in the message
	tf::pointTFToMsg(averageVectors(cts_st->states[i].contact_positions),C_T_L->contact_pose.pose.position);
        //Contact pose is generated via projecting the pose of the link frame on the nullspace of
        //the average normal specified in the message
	tf::quaternionTFToMsg(projectPose(averageVectors(cts_st->states[i].contact_normals)).normalize(),C_T_L->contact_pose.pose.orientation);
       
        C_T_L->contact_pose.touching=true;  //Phalange geometry and target object geometry are in contact
        lock_.unlock();

        tf_filter_->add(C_T_L);//Push the current pose on the filter queue

	//Publish the contact pose 
	geometry_msgs::PoseStamped P;
        P.header=C_T_L->header;
	P.pose=C_T_L->contact_pose.pose;
        ct_pose_pub_.publish(P);

        return;
      }    

  lock_.unlock();

  //Use the reference contact pose if no contact is made
  tf::pointTFToMsg(L_T_Cref_.getOrigin(),C_T_L->contact_pose.pose.position);
  tf::quaternionTFToMsg(L_T_Cref_.getRotation(),C_T_L->contact_pose.pose.orientation);

  C_T_L->contact_pose.touching=false;
  tf_filter_->add(C_T_L);

  //Publish the contact pose 
  geometry_msgs::PoseStamped P;
  P.header=C_T_L->header;
  P.pose=C_T_L->contact_pose.pose;
  ct_pose_pub_.publish(P);
}
//---------------------------------------------------------------------
bool Phalange::setTargetObj(boost::shared_ptr<Model> const & object_model)
{

  lock_.lock();
  object_model_=object_model;
  tf_filter_->setTargetFrame(object_model_->frame_id_);//Set the filter's target frame to the current target object
  lock_.unlock();
  return true;
}
//---------------------------------------------------------------------
tf::Vector3 Phalange::averageVectors(std::vector<geometry_msgs::Vector3> const & vecs)
{
  tf::Vector3 avg_v(0,0,0);

  //Not very nice to return a zero vector in case of an empty input list, but well ...
  if (vecs.size()==0)
    return avg_v;        

  for (unsigned int i=0; i < vecs.size();i++ )
    avg_v+=tf::Vector3(vecs[i].x,vecs[i].y,vecs[i].z);
  

  return avg_v/=vecs.size();
}
//---------------------------------------------------------------------
tf::Quaternion Phalange::projectPose(tf::Vector3 const & z)
{
  tf::Quaternion ori;
  Eigen::Vector3d z_Cref;  

  //The transposed rotation matrix containing the basis of the new contact frame expressed in the
  //reference contact frame. It is transposed since btMatrix3x3 only allows row-wise access
  btMatrix3x3 Cref_R_C;

  //Express z (given in the link frame) in the contact reference frame
  tf::VectorTFToEigen(L_T_Cref_.inverse()*z,z_Cref); 
  z_Cref.normalize();//Assert unit normal

  //Generate the matrix I-n*n^T for projecting on the nullspace of the new z-axis. The nullspace
  //is perpendicular to z.
  Eigen::Matrix3d P = (Eigen::Matrix3d()).setIdentity()-z_Cref*z_Cref.transpose();
  
  //Project the x & y axis of the contact reference frame - this is unstable if one of these axis is
  //(nearly) orthogonal to the nullspace - there should be some check on the norm of the projections ...
  tf::VectorEigenToTF((P*Eigen::Vector3d(1,0,0)).normalized(),Cref_R_C[0]);
  tf::VectorEigenToTF((P*Eigen::Vector3d(0,1,0)).normalized(),Cref_R_C[1]);
  tf::VectorEigenToTF(z_Cref,Cref_R_C[2]);
    
  //Transformation from the new contact frame to the reference frame
  tf::Transform Cref_T_C(Cref_R_C.transpose(),tf::Vector3(0,0,0));

  //Return the orientation (the position is computed in the listenContacts callback by simply
  //averaging the positions contained in the gazebo_msgs/ContactsState msg)
  return L_T_Cref_*Cref_T_C.getRotation();
}
//---------------------------------------------------------------------
bool Phalange::setPose(icr::SetPose::Request  &req, icr::SetPose::Response &res)
{
  //Sets the pose of the contact reference w.r.t the phalange link frame
  res.success=false;
  lock_.lock();

  L_T_Cref_.setOrigin(tf::Vector3(req.origin.x,req.origin.y,req.origin.z));
  L_T_Cref_.setRotation(tf::createQuaternionFromRPY(req.rpy.x,req.rpy.y,req.rpy.z));

  lock_.unlock();
  res.success=true;
  return res.success;
}
//---------------------------------------------------------------------
boost::shared_ptr<Model> Phalange::getPhalangeModel()
{
  //return a copy for thread safety
  lock_.lock();
  boost::shared_ptr<Model> phalange_model(new Model(*phalange_model_.get()));
  lock_.unlock();

  return phalange_model;
}
//---------------------------------------------------------------------
icr::StampedContactPose::ConstPtr Phalange::getStampedContactPose()
{
  //return a copy for thread safety
  lock_.lock();
  icr::StampedContactPose::ConstPtr C_T_O(new icr::StampedContactPose(*C_T_O_.get()));
  lock_.unlock();

  return C_T_O;
}
//---------------------------------------------------------------------
